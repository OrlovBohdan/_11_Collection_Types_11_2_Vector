#[test]

/*

fn main() {
    let arr: [u8; 3] = [1, 2, 3];

    let v = Vec::from(arr);
    is_vec(&v);

    let v = vec![1, 2, 3];
    is_vec(&v);

    // vec!(..) and vec![..] are same macros, so
    let v = vec!(1, 2, 3);
    is_vec(&v);

    // In code below, v is Vec<[u8; 3]> , not Vec<u8>
    // USE Vec::new and `for` to rewrite the below code
    let v1 = vec!(arr);
    is_vec(&v1);

    assert_eq!(v, v1);

    println!("Success!");
}

fn is_vec(v: &Vec<u8>) {}
*/

fn main() {
    let arr: [u8; 3] = [1, 2, 3]; // Инициализация массива из трех байтовых значений

    let v = Vec::from(arr); // Создание вектора из массива
    is_vec(&v); // Проверка, является ли v вектором

    let v = vec![1, 2, 3]; // Создание вектора с использованием макроса vec!
    is_vec(&v); // Проверка, является ли v вектором

    // vec!(..) и vec![..] - это одинаковые макросы
    let v = vec!(1, 2, 3); // Создание вектора с использованием другого синтаксиса
    is_vec(&v); // Проверка, является ли v вектором

    // Используем Vec::new и цикл for для создания Vec<u8> из массива
    let mut v1 = Vec::new(); // Создание нового пустого вектора
    for &item in &arr {      // Итерация по элементам массива
        v1.push(item);       // Добавление каждого элемента в вектор v1
    }

    is_vec(&v1); // Проверка, является ли v1 вектором

    assert_eq!(v, v1); // Проверка на равенство векторов v и v1

    println!("Success!"); // Вывод сообщения об успешном выполнении
}

fn is_vec(_v: &Vec<u8>) {} // Функция для проверки, является ли v вектором


/*
let mut v1 = Vec::new();: Инициализация нового пустого вектора.
for &item in &arr { ... }: Итерация по элементам массива arr. Мы используем &arr, чтобы получить ссылку на массив, и &item, чтобы распаковать ссылку и получить значение элемента.
v1.push(item);: Добавление элемента в вектор v1.
*/
